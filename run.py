#!/usr/bin/env python3
"""
run.py
Convierte un archivo SVG en un recorrido G-code para plotters o CNC sencillos.
Requiere: svgpathtools, numpy.
"""

from __future__ import annotations

import math
import sys
from pathlib import Path
from typing import Iterable, List, Tuple
import logging

import numpy as np
from src.svg_loader import SvgLoader
from src.config import (
    SVG_INPUT_DIR, GCODE_OUTPUT_DIR, FEED, Z_UP, Z_DOWN,
    CMD_DOWN, CMD_UP, STEP_MM, DWELL_MS, MAX_HEIGHT_MM
)

# ---------------------- Parámetros de usuario ---------------------- #
def select_svg_file() -> Path:
    " Selecciona un archivo SVG de la carpeta svg_input."
    svg_dir = SVG_INPUT_DIR
    svg_files = sorted(svg_dir.glob("*.svg"))
    if not svg_files:
        sys.exit("No se encontraron archivos SVG en svg_input.")
    print("Archivos SVG disponibles:")
    for idx, f in enumerate(svg_files, 1):
        print(f"  {idx}. {f.name}")
    while True:
        try:
            sel = int(input(f"Seleccione un archivo SVG (1-{len(svg_files)}): "))
            if 1 <= sel <= len(svg_files):
                return svg_files[sel-1]
        except (ValueError, TypeError):
            pass
        print("Selección inválida. Intente de nuevo.")

def next_gcode_filename(svg_file: Path) -> Path:
    "Genera un nombre de archivo de salida con sufijo _vXX.gcode, incrementando XX si ya existe."
    out_dir = GCODE_OUTPUT_DIR
    stem = svg_file.stem
    for i in range(100):
        candidate = out_dir / f"{stem}_v{i:02d}.gcode"
        if not candidate.exists():
            return candidate
    sys.exit("Demasiados archivos de salida para este SVG.")

SVG_FILE   = select_svg_file()
GCODE_FILE = next_gcode_filename(SVG_FILE)

logging.basicConfig(
    level=logging.INFO,
    format='[%(levelname)s] %(message)s'
)
logger = logging.getLogger(__name__)

def _viewbox_scale(svg_attr: dict) -> float:
    """
    Intenta deducir la escala px→mm a partir del viewBox y del ancho/alto declarados.
    Si no es posible, usa 1.0 (asume que el SVG ya está en mm).
    """
    vb = svg_attr.get("viewBox")
    width = svg_attr.get("width")
    if vb and width:
        try:
            _, _, vb_w, _ = map(float, vb.split())
            width_px = float(width.rstrip("px"))
            return width_px / vb_w
        except ValueError:
            pass
    return 1.0


def sample_path(path, step: float) -> Iterable[Tuple[float, float]]:
    """
    Devuelve puntos (x, y) equiespaciados a lo largo de un Path de svgpathtools.
    """
    for seg in path:
        seg_len = seg.length()
        n = max(1, int(math.ceil(seg_len / step)))
        for t in np.linspace(0, 1, n + 1):
            z = seg.point(t)
            yield z.real, z.imag


def get_svg_bbox(paths):
    """Obtiene el bounding box (xmin, xmax, ymin, ymax) de todos los paths."""
    xs, ys = [], []
    for p in paths:
        for seg in p:
            for t in np.linspace(0, 1, 20):
                z = seg.point(t)
                xs.append(z.real)
                ys.append(z.imag)
    return min(xs), max(xs), min(ys), max(ys)

def write_gcode(paths, scale: float) -> List[str]:
    """
    Genera una lista de líneas G-code a partir de una colección de paths, girando 180° el resultado.
    """
    g: List[str] = []
    g.append("(Generated by simple_svg2gcode)")
    g += ["G90", "G21", f"G0 Z{Z_UP}"]   # absoluto, mm, altura segura

    # Calcular bounding box para girar 180° respecto al centro
    xmin, xmax, ymin, ymax = get_svg_bbox(paths)
    cx, cy = (xmin + xmax) / 2, (ymin + ymax) / 2

    def rotate180(x, y):
        # Rotar 180° respecto al centro
        x2 = 2*cx - x
        y2 = 2*cy - y
        return x2, y2

    def mirror_horizontal(x, y):
        # Espejar horizontalmente respecto al centro cx
        return 2*cx - x, y

    for idx, p in enumerate(paths):
        logger.info("Procesando path %d/%d", idx+1, len(paths))
        first_point = True
        for x, y in sample_path(p, STEP_MM):
            x, y = rotate180(x, y)
            x, y = mirror_horizontal(x, y)
            x_mm, y_mm = x * scale, y * scale
            if first_point:
                logger.debug("Inicio de trazo en X=%.3f, Y=%.3f", x_mm, y_mm)
                # Levantar lapicera y moverse rápido al inicio del trazo
                g += [f"G0 Z{Z_UP}", f"G0 X{x_mm:.3f} Y{y_mm:.3f}",
                      f"G0 Z{Z_DOWN}", CMD_DOWN, f"G4 P{DWELL_MS / 1000.0:.3f}"]
                first_point = False
            g.append(f"G1 X{x_mm:.3f} Y{y_mm:.3f} F{FEED}")
        # Al terminar el trazo, levantar lapicera
        logger.debug("Fin de trazo %d, levantando lapicera", idx+1)
        g += [CMD_UP, f"G4 P{DWELL_MS / 1000.0:.3f}", f"G0 Z{Z_UP}"]

    g += ["M5", "G0 X0 Y0", "(End)"]
    return g


def adjust_scale_for_max_height(paths, scale, max_height_mm):
    """
    Ajusta la escala para que la altura máxima no supere max_height_mm.
    Si la altura ya es menor o igual, retorna la escala original.
    """
    _, _, ymin, ymax = get_svg_bbox(paths)
    height = abs(ymax - ymin) * scale
    if height > max_height_mm:
        factor = max_height_mm / (abs(ymax - ymin) * scale)
        return scale * factor
    return scale


def main() -> None:
    "Genera un archivo G-code a partir de un SVG seleccionado."
    if not SVG_FILE.is_file():
        sys.exit(f"No se encuentra el archivo: {SVG_FILE}")

    svg = SvgLoader(SVG_FILE)
    paths = svg.get_paths()
    svg_attr = svg.get_attributes()
    scale = _viewbox_scale(svg_attr)
    # Ajustar escala si la altura máxima supera el límite
    scale = adjust_scale_for_max_height(paths, scale, MAX_HEIGHT_MM)

    gcode_lines = write_gcode(paths, scale)

    with GCODE_FILE.open("w", encoding="utf-8") as f:
        f.write("\n".join(gcode_lines))

    print("✅ Listo ➜", GCODE_FILE)


if __name__ == "__main__":
    main()

#!/usr/bin/env python3
"""
run.py
Convierte un archivo SVG en un recorrido G-code para plotters o CNC sencillos.
Requiere: svgpathtools, numpy.
"""

from __future__ import annotations

import math
import sys
from pathlib import Path
from typing import Iterable, List, Tuple

import numpy as np
from svg_loader import SvgLoader

# ---------------------- Parámetros de usuario ---------------------- #
def select_svg_file() -> Path:
    " Selecciona un archivo SVG de la carpeta svg_input."
    svg_dir = Path("svg_input")
    svg_files = sorted(svg_dir.glob("*.svg"))
    if not svg_files:
        sys.exit("No se encontraron archivos SVG en svg_input.")
    print("Archivos SVG disponibles:")
    for idx, f in enumerate(svg_files, 1):
        print(f"  {idx}. {f.name}")
    while True:
        try:
            sel = int(input(f"Seleccione un archivo SVG (1-{len(svg_files)}): "))
            if 1 <= sel <= len(svg_files):
                return svg_files[sel-1]
        except (ValueError, TypeError):
            pass
        print("Selección inválida. Intente de nuevo.")

def next_gcode_filename(svg_file: Path) -> Path:
    "Genera un nombre de archivo de salida con sufijo _vXX.gcode, incrementando XX si ya existe."
    out_dir = Path("gcode_output")
    stem = svg_file.stem
    for i in range(100):
        candidate = out_dir / f"{stem}_v{i:02d}.gcode"
        if not candidate.exists():
            return candidate
    sys.exit("Demasiados archivos de salida para este SVG.")

SVG_FILE   = select_svg_file()
GCODE_FILE = next_gcode_filename(SVG_FILE)

FEED      = 400          # mm/min
Z_UP      = 5            # altura segura
Z_DOWN    = 0            # altura de dibujo / corte
CMD_DOWN  = "M3 S50"     # baja herramienta / prende láser
CMD_UP    = "M5"         # levanta herramienta / apaga láser
STEP_MM   = 0.3          # resolución de muestreo sobre cada segmento
DWELL_MS  = 150          # pausa (ms) tras subir/bajar herramienta
# ------------------------------------------------------------------ #


def _viewbox_scale(svg_attr: dict) -> float:
    """
    Intenta deducir la escala px→mm a partir del viewBox y del ancho/alto declarados.
    Si no es posible, usa 1.0 (asume que el SVG ya está en mm).
    """
    vb = svg_attr.get("viewBox")
    width = svg_attr.get("width")
    if vb and width:
        try:
            _, _, vb_w, _ = map(float, vb.split())
            width_px = float(width.rstrip("px"))
            return width_px / vb_w
        except ValueError:
            pass
    return 1.0


def sample_path(path, step: float) -> Iterable[Tuple[float, float]]:
    """
    Devuelve puntos (x, y) equiespaciados a lo largo de un Path de svgpathtools.
    """
    for seg in path:
        seg_len = seg.length()
        n = max(1, int(math.ceil(seg_len / step)))
        for t in np.linspace(0, 1, n + 1):
            z = seg.point(t)
            yield z.real, z.imag


def get_svg_bbox(paths):
    """Obtiene el bounding box (xmin, xmax, ymin, ymax) de todos los paths."""
    xs, ys = [], []
    for p in paths:
        for seg in p:
            for t in np.linspace(0, 1, 20):
                z = seg.point(t)
                xs.append(z.real)
                ys.append(z.imag)
    return min(xs), max(xs), min(ys), max(ys)

def write_gcode(paths, scale: float) -> List[str]:
    """
    Genera una lista de líneas G-code a partir de una colección de paths, girando 180° el resultado.
    """
    g: List[str] = []
    g.append("(Generated by simple_svg2gcode)")
    g += ["G90", "G21", f"G0 Z{Z_UP}"]   # absoluto, mm, altura segura

    # Calcular bounding box para girar 180° respecto al centro
    xmin, xmax, ymin, ymax = get_svg_bbox(paths)
    cx, cy = (xmin + xmax) / 2, (ymin + ymax) / 2

    def rotate180(x, y):
        # Rotar 180° respecto al centro
        x2 = 2*cx - x
        y2 = 2*cy - y
        return x2, y2

    def mirror_horizontal(x, y):
        # Espejar horizontalmente respecto al centro cx
        return 2*cx - x, y

    for p in paths:
        first_point = True
        for x, y in sample_path(p, STEP_MM):
            x, y = rotate180(x, y)
            x, y = mirror_horizontal(x, y)
            x_mm, y_mm = x * scale, y * scale
            if first_point:
                # Levantar lapicera y moverse rápido al inicio del trazo
                g += [f"G0 Z{Z_UP}", f"G0 X{x_mm:.3f} Y{y_mm:.3f}",
                      f"G0 Z{Z_DOWN}", CMD_DOWN, f"G4 P{DWELL_MS / 1000.0:.3f}"]
                first_point = False
            g.append(f"G1 X{x_mm:.3f} Y{y_mm:.3f} F{FEED}")
        # Al terminar el trazo, levantar lapicera
        g += [CMD_UP, f"G4 P{DWELL_MS / 1000.0:.3f}", f"G0 Z{Z_UP}"]

    g += ["M5", "G0 X0 Y0", "(End)"]
    return g


def main() -> None:
    "Genera un archivo G-code a partir de un SVG seleccionado."
    if not SVG_FILE.is_file():
        sys.exit(f"No se encuentra el archivo: {SVG_FILE}")

    svg = SvgLoader(SVG_FILE)
    paths = svg.get_paths()
    svg_attr = svg.get_attributes()
    scale = _viewbox_scale(svg_attr)

    gcode_lines = write_gcode(paths, scale)

    with GCODE_FILE.open("w", encoding="utf-8") as f:
        f.write("\n".join(gcode_lines))

    print("✅ Listo ➜", GCODE_FILE)


if __name__ == "__main__":
    main()
